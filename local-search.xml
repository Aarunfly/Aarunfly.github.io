<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git连接github超时以及缓慢</title>
    <link href="/2022/08/19/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2022/08/19/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>由于今天改动完提交git代码时老是请求超时，开了梯子也不行于是找了一个方法完美解决顺便记录下<br>ping github.com<br>PING github.com (192.30.253.112): 56 data bytes<br>64 bytes from 192.30.253.112: icmp_seq&#x3D;0 ttl&#x3D;47 time&#x3D;245.930 ms<br>64 bytes from 192.30.253.112: icmp_seq&#x3D;1 ttl&#x3D;47 time&#x3D;245.910 ms<br>记录ip 192.30.253.112</p><p>得到ip 在host中添加即可<br>$ sudo vim&#x2F;etc&#x2F;hosts<br>192.30.253.112 github.com<br>151.101.113.194 github.global.ssl.fastly.net</p><p>　最后更新DNS缓存</p><p>$ sudo dscacheutil -flushcache</p>]]></content>
    
    
    <categories>
      
      <category>问题汇总</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>header字段</title>
    <link href="/2022/08/02/%E7%BD%91%E7%BB%9C/header%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5/"/>
    <url>/2022/08/02/%E7%BD%91%E7%BB%9C/header%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<p>Accept             客户端-&gt;服务端    客户端期望服务器返回的媒体格式<br>Accept-Charset     客户端-&gt;服务端   客户端期望服务器返回的内容的编码格式<br>Content-Type       服务端-&gt;客户端    代表内容的媒体类型和编码格式<br>Accept-Language    客户端-&gt;服务端    返回的语言<br>Content-Language   服务端-&gt;客户端    告知客户端返回内容的语言<br>Content-Length     服务端-&gt;客户端    告知客户端返回内容的长度   get请求没有body所以没有<br>Expires            服务端-&gt;客户端     服务器使用Expect头来告知对方资源何时失效。如果它的值等于Date头的值，就表示资源已经实效   Expires: Thu, 01 Dec 1994 16:00:00 GMT<br>ETag               资源标签     一般用来和If-Match和If-None-Match配合使用，用来判断缓存资源的有效性<br>If-Match           值一般是上面提到的ETag的值<br>If-None-Match      类似于If-Match，只是条件相反<br>Connection         当客户端和服务器需要协商连接的属性时，可以使用Connection头部。比较常用的一个值是close，用来通知对方在当前请求结束后关闭连接。<br>Host               RFC协议规定所有的HTTP请求必须携带Host头，即使Host没有值，也必须带上这个Host头附加一个空串，如果不满足，应用服务器应该抛出400 Bad Request<br>Last-Modified      标记资源的最近修改时间，它和Date比较类似，区别是Last-Modified代表修改时间，而Date是创建时间。<br>If-Modified-Since  浏览器向服务器请求静态资源时，如果浏览器本地已经有了缓存，就会携带If-Modified-Since头，值为资源的Last-Modified时间，询问服务器该资源自从这个Last-Modified时间之后有没有被修改。如果没有修改过，就会向浏览器返回304 Not Modified通知浏览器可以放心使用缓存内的资源。如果资源修改过，那就像正常的GET请求一样，携带资源的内容返回200 OK。<br>Range              支持断点续传的服务器必须处理Range头，它表示客户端请求资源的一部分时指定的请求字节范围。它是客户端向服务器发送的请求头。     Range: bytes&#x3D;500-999<br>Transfer-Encoding  传送Body信息时需要对Body数据采取何种变换。当HTTP对Body进行分块传送时，需要增加下面的头部信息才可以进行分块传送。其它类型目前没有遇到过。<br>Referer            Referer是非常常用的头，它表示请求的发起来源URI，也就是当前页面资源的父页面</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>已知状态码</title>
    <link href="/2022/07/16/%E7%BD%91%E7%BB%9C/status%20code/"/>
    <url>/2022/07/16/%E7%BD%91%E7%BB%9C/status%20code/</url>
    
    <content type="html"><![CDATA[<h1 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h1><h2 id="资源正在请求中"><a href="#资源正在请求中" class="headerlink" title="资源正在请求中"></a>资源正在请求中</h2><h1 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h1><h2 id="200-资源请求成功"><a href="#200-资源请求成功" class="headerlink" title="200 资源请求成功"></a>200 资源请求成功</h2><h2 id="204-资源请求成功但无资源返回"><a href="#204-资源请求成功但无资源返回" class="headerlink" title="204 资源请求成功但无资源返回"></a>204 资源请求成功但无资源返回</h2><h1 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h1><h2 id="301-永久重定向"><a href="#301-永久重定向" class="headerlink" title="301 永久重定向"></a>301 永久重定向</h2><h2 id="302-临时重定向"><a href="#302-临时重定向" class="headerlink" title="302 临时重定向"></a>302 临时重定向</h2><h2 id="304-协商缓存"><a href="#304-协商缓存" class="headerlink" title="304 协商缓存"></a>304 协商缓存</h2><h1 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h1><h1 id="400-服务端无法解析http请求语法"><a href="#400-服务端无法解析http请求语法" class="headerlink" title="400 服务端无法解析http请求语法"></a>400 服务端无法解析http请求语法</h1><h1 id="401-未授权-需要验证身份"><a href="#401-未授权-需要验证身份" class="headerlink" title="401 未授权 需要验证身份"></a>401 未授权 需要验证身份</h1><h1 id="403-服务器拒接访问"><a href="#403-服务器拒接访问" class="headerlink" title="403 服务器拒接访问"></a>403 服务器拒接访问</h1><h1 id="404-页面资源未找到（一般路由配置出现）"><a href="#404-页面资源未找到（一般路由配置出现）" class="headerlink" title="404 页面资源未找到（一般路由配置出现）"></a>404 页面资源未找到（一般路由配置出现）</h1><h1 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h1><h1 id="500-服务器内部错误"><a href="#500-服务器内部错误" class="headerlink" title="500 服务器内部错误"></a>500 服务器内部错误</h1><h1 id="503-服务器无法使用-或者挂了"><a href="#503-服务器无法使用-或者挂了" class="headerlink" title="503 服务器无法使用 或者挂了"></a>503 服务器无法使用 或者挂了</h1>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http 1.0/1.1/2</title>
    <link href="/2022/07/14/%E7%BD%91%E7%BB%9C/http/"/>
    <url>/2022/07/14/%E7%BD%91%E7%BB%9C/http/</url>
    
    <content type="html"><![CDATA[<h1 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h1><h2 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h2><h2 id="无host"><a href="#无host" class="headerlink" title="无host"></a>无host</h2><h2 id="断电无法重连"><a href="#断电无法重连" class="headerlink" title="断电无法重连"></a>断电无法重连</h2><h1 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h1><h2 id="增加缓存"><a href="#增加缓存" class="headerlink" title="增加缓存"></a>增加缓存</h2><h2 id="增加host"><a href="#增加host" class="headerlink" title="增加host"></a>增加host</h2><h2 id="增加长连接"><a href="#增加长连接" class="headerlink" title="增加长连接"></a>增加长连接</h2><h2 id="数据包形式传输"><a href="#数据包形式传输" class="headerlink" title="数据包形式传输"></a>数据包形式传输</h2><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><h2 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h2><h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><h2 id="服务端推送（server-push）"><a href="#服务端推送（server-push）" class="headerlink" title="服务端推送（server push）"></a>服务端推送（server push）</h2>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端路由</title>
    <link href="/2022/06/21/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    <url>/2022/06/21/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<p>关于前端路由主要分为 Hash 还有就是history 这两种</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>hash 主要是使用#分割，当页面切换时不会刷新页面<br>onChange是更改他的方法<br>由于切换页面不刷新所以受SPA的青睐设为默认路由</p><p>history 主要是通过配置路由来进行跳转，跳转时页面会发生Http请求，所以比较掉性能，如果没有配置地址则请求失败code返回404（页面不存在）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法小探</title>
    <link href="/2022/06/15/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/"/>
    <url>/2022/06/15/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>安利一波资源 拉布拉多整挺好： <a href="https://labuladong.github.io/algo/1/">https://labuladong.github.io/algo/1/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>功能说明</title>
    <link href="/2022/06/14/%E5%BB%BA%E7%AB%99%E8%AF%B4%E6%98%8E/"/>
    <url>/2022/06/14/%E5%BB%BA%E7%AB%99%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>此次建站主要是因为云服务器到期以及域名释放，为跟随公司降本增效策略，三思后决定使用 github page 来搭建我的记录平台</p><!-- ## Quick Start --><!-- ### Create a new post --><!-- ``` bash$ hexo new "My New Post"<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>More info: [Writing](https:<span class="hljs-regexp">//</span>hexo.io<span class="hljs-regexp">/docs/</span>writing.html)<br><br><span class="hljs-comment">### Run server</span><br><br>``` bash<br>$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a> –&gt;</p>]]></content>
    
    
    <categories>
      
      <category>说明</category>
      
    </categories>
    
    
    <tags>
      
      <tag>说明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写记录</title>
    <link href="/2022/06/14/js%E6%89%8B%E5%86%99/js%E6%89%8B%E5%86%99%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/06/14/js%E6%89%8B%E5%86%99/js%E6%89%8B%E5%86%99%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="从理解到落地"><a href="#从理解到落地" class="headerlink" title="从理解到落地"></a>从理解到落地</h1><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>function deepClone(obj,map &#x3D; new Map()){<br>    &#x2F;&#x2F;typeof（只能检测原始值） 检测原始值返回<br>if(typeof obj !&#x3D;&#x3D; ‘Object’ ){<br>   return obj;<br>}</p><p>&#x2F;&#x2F;map（key可以为对象特点）防止自己对自己属性赋值导致无限递归</p><p>if(map.get(obj)){<br>   return map.get(obj);<br>}</p><p>let result &#x3D; {};<br> &#x2F;&#x2F;判断是否为数组方法 Array.isArray()、Object.protoutype.toString.calll() &#x3D;&#x3D;&#x3D; ‘[Object array]’、 不能使用 instanceof 来检测数组 （不严谨）<br>if(<br>    Array.isArray(obj) ||<br>    Object.protoutype.toString.call(obj) &#x3D;&#x3D;&#x3D; “[Object array]”<br>    ){<br>     result &#x3D; []<br>}</p><p>map.set(result,obj)</p><p>&#x2F;&#x2F; 核心递归<br>for(const key in obj){<br>    &#x2F;&#x2F; hasOwnProperty() 查看该属性是否在此对象中<br>    if(obj.hasOwnProperty(key)){<br>        result[key] &#x3D; deepClone(obj[key])<br>    }<br>}</p><p>return result;<br>}</p><h2 id="数组拍平"><a href="#数组拍平" class="headerlink" title="数组拍平"></a>数组拍平</h2><p>function falt(arr,deep &#x3D; 1){<br>    if(deep&gt;0){<br>       return arr.reduce((per,cur)&#x3D;&gt;{<br>            return per.concat(Array.isArray(cur)?falt(cur):cur)<br>       },[])<br>    }<br>    return arr.slice();<br>}</p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>function uniqueArray(arr){<br> let slow &#x3D; 0;<br> let fast &#x3D; 0;<br> let result &#x3D; [];<br> whlie(fast &lt; arr.length){<br>    if(arr[slow] &#x3D;&#x3D; arr[fast]){<br>        fast++;<br>    }else{<br>        slow++;<br>        arr[slow] &#x3D; arr[fast];<br>        result.push(arr[fast])<br>    }<br> }<br> return result;&#x2F;&#x2F;去重数组<br> return slow+1；&#x2F;&#x2F;不重复元素个数<br>}</p><h2 id="数据双向绑定"><a href="#数据双向绑定" class="headerlink" title="数据双向绑定"></a>数据双向绑定</h2><p>let obj &#x3D; {};<br>let input &#x3D; document.getElementById(‘input’);<br>let span &#x3D; document.getElementById(‘span’);<br>Object.defineProperty(obj,’text’,{<br>    configurable: true,<br>    enumerable: true,<br>    get(){<br>     console.log(‘数据获取了’）<br>    }<br>    set(newVal){<br>    console.log(‘数据更新了’)<br>    input.value &#x3D; newVal;<br>    span.innerHTML &#x3D;newVal;<br>    }<br>})<br> input.addEvenLisener(‘keyup’,(e)&#x3D;&gt;{<br>       obj.text &#x3D; e.target.value<br>    })</p><h2 id="reduce求和"><a href="#reduce求和" class="headerlink" title="reduce求和"></a>reduce求和</h2><p>function sum(arr){<br>return arr.reduce((per,cur)&#x3D;&gt;{<br>    return per+cur<br>},0)<br>}</p><h2 id="将js对象转化成树形结构"><a href="#将js对象转化成树形结构" class="headerlink" title="将js对象转化成树形结构"></a>将js对象转化成树形结构</h2><p>const arr &#x3D; [{<br>    name:’中国’,<br>    id:1,<br>    parentId:0<br>},{<br>    name:’北京’,<br>    id:2,<br>    parentId:1<br>},{<br>    name:’上海’,<br>    id:3,<br>    parentId:1<br>},{<br>    name:’台湾’,<br>    id:4,<br>    parentId:1<br>},{<br>    name:’钓鱼岛’,<br>    id:5,<br>    parentId:4<br>}]</p><p>function toTree(data,key &#x3D; ‘id’,parentId &#x3D; 0){<br>    &#x2F;&#x2F;边界值判断 非数组返回<br> if(!Array.isArray(data)){<br>     return data<br> }</p><p>   &#x2F;&#x2F;边界值判断 数组元素为1返回<br>if(data.length &#x3D;&#x3D; 1){<br>  return  data;<br>}</p><p> let result &#x3D; [];<br> 循环整个数组需找<br> date.forEach((item)&#x3D;&gt;{<br>    &#x2F;&#x2F;符合条件 当循环item的id符合于当层parentId进入下一层递归<br>     if(item.id &#x3D;&#x3D; parentId){<br>         &#x2F;&#x2F;符合条件给当前item增加一属性children 并递归赋值，第三个参数是下一层需要寻找的id值<br>        item.children &#x3D; toTree(data,key,item[key])<br>        result.push(item)<br>     }<br> })<br> return result;<br>}</p>]]></content>
    
    
    <categories>
      
      <category>js手写</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
